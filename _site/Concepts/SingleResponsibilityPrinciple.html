<!DOCTYPE html>
<html>
  ﻿<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <meta name="format-detection" content="telephone=no">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="description" content="Guidelines by Promact">
  <meta name="author" content="Dharmesh Pipariya">
  <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico">

  <title>Your awesome title</title>

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css">
  <!--<link rel="stylesheet" href="stylesheets/github-light.css">
  <link rel="stylesheet" href="stylesheets/style.css">-->

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/Concepts/SingleResponsibilityPrinciple.html">
  <link rel="alternate" type="application/rss+xml" title="Your awesome title" href="http://yourdomain.com/feed.xml">

  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>
<body>
  <div class="wrapper">
    <nav class="aside-menu">
  <div class="logo">
    <a href="/">
      <img src="/images/logo.png" />
    </a>
  </div>
  <ul>
    <li><a href="#">AngularJS</a></li>
    <li>
      <a href="#">Concepts <i class="fa fa-angle-down"></i></a>
      <ul>
        <li><a href="/Concepts/ObjectOrientedPrograming.html">Object Oriented Programing</a></li>
        <li><a href="/Concepts/SingleResponsibilityPrinciple.html">SingleResponsibilityPrinciple</a></li>
      </ul>
    </li>
    <li><a href="#">Elasticsearch</a></li>
    <li>
      <a href="#">Git <i class="fa fa-angle-down"></i></a>
      <ul>
        <li><a href="/Git/Workflow.html">Workflow</a></li>
      </ul>
    </li>
    <li>
      <a href="#">Microsoft <i class="fa fa-angle-down"></i></a>
      <ul>
        <li><a href="#">Autofac <i class="fa fa-angle-down"></i></a></li>
        <li>
          <a href="#">C-Sharp <i class="fa fa-angle-down"></i></a>
          <ul>
            <li><a href="/Microsoft/C-Sharp/StructureOfClass.html">Structure Of Class</a></li>
          </ul>
        </li>
        <li>
          <a href="#">Entity Framework <i class="fa fa-angle-down"></i></a>
          <ul>
            <li><a href="/Microsoft/EntityFramework/BestPractices.html">Best Practices</a></li>
            <li><a href="/Microsoft/EntityFramework/Concepts.html">Concepts</a></li>
            <li><a href="/Microsoft/EntityFramework/Migrations.html">Migrations</a></li>
          </ul>
        </li>
        <li>
          <a href="#">MVC <i class="fa fa-angle-down"></i></a>
          <ul>
            <li><a href="/Microsoft/MVC/ProjectStructure.html">Project Structure</a></li>
          </ul>
        </li>
        <li>
          <a href="#">OWIN <i class="fa fa-angle-down"></i></a>
          <ul>
            <li><a href="/Microsoft/OWIN/Implementation.html">Implementation</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <a href="#">Mobile <i class="fa fa-angle-down"></i></a>
      <ul>
        <li>
          <a href="#">Swift <i class="fa fa-angle-down"></i></a>
          <ul>
            <li><a href="/Mobile/Swift/StructVsClass.html">Struct vs Class</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <a href="#">MySQL <i class="fa fa-angle-down"></i></a>
      <ul>
        <li><a href="/MySQL/indexingGuide.html">Indexing Guide</a></li>
      </ul>
    </li>
    <li><a href="#">NodeJS</a></li>
    <li><a href="#">PHP</a></li>
    <li><a href="#">Python</a></li>
  </ul>
  <!--<ul>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>-->
</nav>
    <div class="container-fluid">
      <div class="header">
        <button type="button" class="nav-toggle btn"><i class="fa fa-bars"></i></button>
        <h1>Guidelines</h1>
      </div>
      <section>
        <article class="post">
  <header class="post-header">
    <h1 class="post-title"></h1>
  </header>
  <div class="post-content">
    <h1 id="srp-single-responsibility-principle">SRP (Single Responsibility Principle)</h1>

<p><strong>- SRP is about making a single method/function do specific task
  or a class/structure do a specific set of functionalities that defines that Type (i.e. class or struct)</strong></p>

<p><strong>Note:</strong>
     <strong><em>I am using Swift, the flagship (now open-source) language of Apple Inc. to demonstrate the SRP principle.</em></strong></p>

<h2 id="srp-in-methodfunction">SRP IN METHOD/FUNCTION</h2>

<p><strong>Example:</strong>
     Taking the example of a Coffee and Tea making machine to explain SRP in method/function</p>

<h4 id="tea-maker">Tea-maker</h4>

<pre><code class="language-Swift">
struct TeaMaker
{
  internal func prepareTea()
  {
     // Prepare tea here
  }

  internal func addMilk()
  {
     // Add milk to tea
  }
}
</code></pre>

<h4 id="coffee-maker">Coffee-maker</h4>

<pre><code class="language-Swift">
struct CoffeeMaker
{
  internal func prepareCoffee()
  {
     // Prepare Coffee here
  }

  internal func addMilk()
  {
     // Add milk to Coffee
  }

}
</code></pre>

<ul>
  <li>
    <p>It’s always a good idea to have a single task assigned to a single methods/functions.</p>
  </li>
  <li>
    <p>Consider Tea which can be with milk or without it, now if we have only one method called prepareTea() with addMilk() method functionality inside it, then the
tea will always be with milk.</p>
  </li>
</ul>

<pre><code class="language-Swift">
struct TeaMaker
{
  // Wrong way to implement a method which does more than one Task
  internal func prepareTea()
  {
     // Prepare tea here
     // Add milk to tea
  }

}
</code></pre>

<ul>
  <li>
    <p>Some people may ague over the point that using a condition factor we can control the addition of milk inside the prepareTea() method but then that leads to violation
 of another Software designing principle named DRY (Don’t Repeat Yourself).</p>
  </li>
  <li>
    <p>Consider there is only one struct/class called HotDrinkMaker, now this can make both tea as well as coffee. Now if we write the addMilk() method inside prepareTea() and prepareCoffee() method
then the addMilk functionality is repeated twice.</p>
  </li>
</ul>

<pre><code class="language-Swift">
struct HotDrinkMaker
{
  // Repetition of add milk functionality
  internal func prepareTea()
  {
     // Prepare tea here
     // Add milk to tea
  }

  // Repetition of add milk functionality
  internal func prepareCoffee()
  {
     // Prepare coffee here
     // Add milk to coffee
  }
}

</code></pre>

<ul>
  <li>Implementing SRP to a method/function prevents violation of DRY.</li>
</ul>

<pre><code class="language-Swift">
struct HotDrinkMaker
{
 
  internal func prepareTea(isBlack: Bool)
  {
     // Prepare tea here

        if !isBlack
        {
            addMilk()
        }
  }

  internal func prepareCoffee(isBlack: Bool)
  {
     // Prepare coffee here

        if !isBlack
        {
            addMilk()
        }
  }
 
  internal func addMilk()
  {
     // Add milk to Coffee
  }
}

</code></pre>

<ul>
  <li>If we try to optimise this HotDrinkMaker struct further then I would prefer the below code.</li>
</ul>

<pre><code class="language-Swift">
enum Drinks
{
    case Tea
    case Coffee
}

enum Milk
{
    case Yes
    case No
}

struct HotDrinkMaker
{
    
    internal func prepareDrink(drink: Drinks, milk: Milk)
    {
        // Prepare drink here
        print("Drink prepared")
        
        if milk == Milk.Yes
        {
            addMilk()
        }
    }
        internal func addMilk()
    {
        // Add milk to Coffee
        print("Milk added")
    }
}

</code></pre>

<h2 id="srp-in-classstruct">SRP IN CLASS/STRUCT</h2>

<ul>
  <li>
    <p>Classes/Structs must follow 2 things.</p>

    <ul>
      <li>SRP</li>
      <li>Cohesiveness</li>
    </ul>
  </li>
  <li>SRP in class/struct deals with grouping of all the functionalities that defines that particular type.</li>
  <li>Cohesiveness is about having all the methods/functions whose functionalities are apt to the name of that class/struct.</li>
</ul>

<p>Example:
     Taking the example of a Car to explain SRP in class/struct</p>

<pre><code class="language-Swift">struct Car
{
  internal func controlSteering()
  {
    // controls the steering of a car
  }

  internal func controlAcceleration()
  {
    // controls the acceleration of a car
  }

  internla func controlBrakes()
  {
    // controls the brakes of a car
  }

}
</code></pre>

<ul>
  <li>
    <p>All the methods above controlSteering(), controlAcceleration() and controlBrakes() does a specific Task and all the methods are apt to the name of the struct that its contained within.</p>
  </li>
  <li>
    <p>Consider I need a method called fillOil() but before that we need to decide few other factors.</p>

    <ul>
      <li>Type of Oil (Petrol, Diesel, Water, Air… who knows about the future !!)</li>
      <li>Categories of Oil (Power, Swift, Energy… etc etc)</li>
    </ul>
  </li>
  <li>So all these are specific to Oil not to Car, so it can’t be a part of it… Thats what SRP is about in class/struct.</li>
  <li>The definition of methods within the Car struct aptly justifies the Type Car here, thats Cohesiveness.</li>
</ul>

<pre><code class="language-Swift">
enum Oils
{
    case Petrol
    case Diesel
}

enum OilTypes
{
    case Power
    case Swift
    case Energy
}


struct Oil
{
    private var oil: Oils?
    private var oilType: OilTypes?
    
    internal init(oil: Oils,oilType: OilTypes)
    {
        self.oil = oil
        self.oilType = oilType
    }
    
    internal var getOil: Oils?
    {
      get
      {
        return self.oil
      }
    }
    
    internal var getOilType: OilTypes?
    {
        get
        {
            return self.oilType
        }
    }
}

struct Car
{
    
    // use of composition principle to include the type (Oil) within a Type (Car) which is a part of it but not fits into its own structure(ie not fits in Car's struct)
    private var oil: Oils?
    
    internal func controlSteering()
    {
        // controls the steering of a car
    }
    
    internal func controlAcceleration()
    {
        // controls the acceleration of a car
    }
    
    internal func controlBrakes()
    {
        // controls the brakes of a car
    }
    
    internal fun fillOil()
    {
       // initialise the oil instance here according to the Car
    }
}

</code></pre>

  </div>
</article>

      </section>
      <footer class="footer clearfix">
  <p class="left">This project is maintained by <a href="https://github.com/Promact">Promact</a></p>
  <p class="right"><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
  <div class="clear"></div>
</footer>
    </div>
  </div>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
  <script src="/javascripts/main.js"></script>
  <script src="/javascripts/scale.fix.js"></script>
</body>
</html>
